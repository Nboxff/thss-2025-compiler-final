# SysY 编译器符号表类型设计

## 概述

本文档定义了从 SysY 语言到 LLVM IR 编译器所需的符号表类型设计。符号表用于管理程序中的标识符（变量、常量、函数）及其作用域信息，支持嵌套作用域和符号查找。

## 核心类型定义

### 1. 符号类型枚举

#### `SymbolType` - 符号类型
```cpp
enum class SymbolType {
    VARIABLE,    // 变量
    CONSTANT,    // 常量
    FUNCTION,    // 函数
    PARAMETER    // 函数参数
};
```

#### `DataType` - 数据类型
```cpp
enum class DataType {
    INT,         // 整数类型
    VOID,        // void 类型（仅用于函数返回类型）
    INT_ARRAY    // 整数数组类型
};
```

---

### 2. 符号条目类

#### `SymbolEntry` - 符号表条目（基类）
表示符号表中的单个条目，存储标识符的基本信息。

**属性：**
- `name: string` - 标识符名称
- `symbolType: SymbolType` - 符号类型（变量、常量、函数、参数）
- `dataType: DataType` - 数据类型
- `isConst: bool` - 是否为常量
- `scopeLevel: int` - 作用域层级（0 表示全局作用域，递增表示嵌套层级）

**方法：**
- `getName(): string` - 获取标识符名称
- `getSymbolType(): SymbolType` - 获取符号类型
- `getDataType(): DataType` - 获取数据类型
- `isConstant(): bool` - 判断是否为常量
- `getScopeLevel(): int` - 获取作用域层级

---

#### `VariableEntry` - 变量条目
继承自 `SymbolEntry`，表示变量或常量。

**属性：**
- `isArray: bool` - 是否为数组
- `dimensions: vector<int>` - 数组维度列表（编译时已知的维度大小）
- `dimExprs: vector<ConstExpNode*>` - 数组维度表达式列表（用于未初始化的数组声明）
- `isInitialized: bool` - 是否已初始化
- `llvmValue: llvm::Value*` - 对应的 LLVM IR 值（在代码生成阶段使用）

**方法：**
- `isArrayType(): bool` - 判断是否为数组类型
- `getArraySize(): int` - 获取数组总大小（各维度乘积）
- `getDimensionCount(): int` - 获取数组维度数
- `getDimension(int index): int` - 获取指定维度的大小

**示例：**
- `int a;` → `isArray = false, dimensions = []`
- `int b[10];` → `isArray = true, dimensions = [10]`
- `int c[2][3];` → `isArray = true, dimensions = [2, 3]`

---

#### `FunctionEntry` - 函数条目
继承自 `SymbolEntry`，表示函数定义。

**属性：**
- `returnType: DataType` - 函数返回类型（`INT` 或 `VOID`）
- `parameters: vector<ParameterEntry*>` - 形式参数列表
- `localSymbolTable: SymbolTable*` - 函数局部符号表
- `llvmFunction: llvm::Function*` - 对应的 LLVM IR 函数（在代码生成阶段使用）
- `isDefined: bool` - 是否已定义（用于区分声明和定义）

**方法：**
- `getReturnType(): DataType` - 获取返回类型
- `getParameterCount(): int` - 获取参数数量
- `getParameter(int index): ParameterEntry*` - 获取指定位置的参数
- `addParameter(ParameterEntry* param)` - 添加参数
- `getLocalSymbolTable(): SymbolTable*` - 获取局部符号表

---

#### `ParameterEntry` - 参数条目
继承自 `VariableEntry`，表示函数参数。

**属性：**
- `paramIndex: int` - 参数在函数参数列表中的索引（从 0 开始）
- `isArrayParam: bool` - 是否为数组参数（如 `int a[]`）
- `arrayDims: vector<int>` - 数组参数的后续维度（第一维为空，如 `int a[][10]` 的 `[10]`）

**方法：**
- `getParamIndex(): int` - 获取参数索引
- `isArrayParameter(): bool` - 判断是否为数组参数

**示例：**
- `int func(int a)` → `isArrayParam = false, arrayDims = []`
- `int func(int a[])` → `isArrayParam = true, arrayDims = []`
- `int func(int a[][10])` → `isArrayParam = true, arrayDims = [10]`

---

### 3. 符号表类

#### `SymbolTable` - 符号表
管理作用域内的符号，支持嵌套作用域和符号查找。

**属性：**
- `symbols: unordered_map<string, SymbolEntry*>` - 符号映射表（键为标识符名称）
- `parent: SymbolTable*` - 指向父作用域符号表的指针（nullptr 表示全局作用域）
- `scopeLevel: int` - 当前作用域层级
- `children: vector<SymbolTable*>` - 子作用域符号表列表（可选，用于作用域遍历）

**方法：**

##### 符号管理
- `insert(SymbolEntry* entry): bool` - 插入符号，返回是否成功（如果已存在同名符号则失败）
- `lookup(const string& name): SymbolEntry*` - 在当前作用域查找符号，返回 nullptr 如果未找到
- `lookupAll(const string& name): SymbolEntry*` - 在当前作用域及所有父作用域中查找符号（遵循作用域规则）
- `remove(const string& name): bool` - 从当前作用域移除符号
- `contains(const string& name): bool` - 检查当前作用域是否包含指定符号
- `containsAll(const string& name): bool` - 检查当前作用域及父作用域是否包含指定符号

##### 作用域管理
- `getParent(): SymbolTable*` - 获取父作用域符号表
- `getScopeLevel(): int` - 获取当前作用域层级
- `createChildScope(): SymbolTable*` - 创建子作用域符号表
- `exitScope(): SymbolTable*` - 退出当前作用域，返回父作用域

##### 遍历和调试
- `getAllSymbols(): vector<SymbolEntry*>` - 获取当前作用域的所有符号
- `print(): void` - 打印符号表内容（用于调试）

---

### 4. 符号表管理器

#### `SymbolTableManager` - 符号表管理器
管理整个程序的符号表层次结构，提供统一的符号查找和管理接口。

**属性：**
- `globalTable: SymbolTable*` - 全局符号表
- `currentTable: SymbolTable*` - 当前作用域符号表
- `functionTable: SymbolTable*` - 当前函数局部符号表（用于快速访问）

**方法：**

##### 作用域管理
- `enterScope(): void` - 进入新的作用域（创建子符号表）
- `exitScope(): void` - 退出当前作用域
- `enterFunction(FunctionEntry* func): void` - 进入函数作用域
- `exitFunction(): void` - 退出函数作用域
- `getCurrentScope(): SymbolTable*` - 获取当前作用域符号表
- `getGlobalScope(): SymbolTable*` - 获取全局作用域符号表

##### 符号查找
- `lookup(const string& name): SymbolEntry*` - 在当前作用域及父作用域中查找符号
- `lookupGlobal(const string& name): SymbolEntry*` - 仅在全局作用域查找符号
- `lookupFunction(const string& name): FunctionEntry*` - 查找函数（仅在全局作用域）
- `lookupVariable(const string& name): VariableEntry*` - 查找变量（在当前作用域及父作用域）

##### 符号插入
- `insertGlobal(SymbolEntry* entry): bool` - 在全局作用域插入符号
- `insertLocal(SymbolEntry* entry): bool` - 在当前作用域插入符号
- `insertFunction(FunctionEntry* func): bool` - 插入函数定义
- `insertVariable(VariableEntry* var): bool` - 插入变量定义
- `insertParameter(ParameterEntry* param): bool` - 插入函数参数

##### 类型检查辅助
- `checkTypeCompatibility(DataType t1, DataType t2): bool` - 检查两个类型是否兼容
- `isArrayType(DataType type): bool` - 判断是否为数组类型
- `getArrayElementType(DataType type): DataType` - 获取数组元素类型

---

## 使用示例

### 示例 1：变量声明
```cpp
// 解析: int a = 10;
VariableEntry* var = new VariableEntry();
var->name = "a";
var->symbolType = SymbolType::VARIABLE;
var->dataType = DataType::INT;
var->isConst = false;
var->isArray = false;
var->isInitialized = true;
var->scopeLevel = manager->getCurrentScope()->getScopeLevel();

manager->insertLocal(var);
```

### 示例 2：数组声明
```cpp
// 解析: int arr[10][20];
VariableEntry* arr = new VariableEntry();
arr->name = "arr";
arr->symbolType = SymbolType::VARIABLE;
arr->dataType = DataType::INT_ARRAY;
arr->isArray = true;
arr->dimensions = {10, 20};
arr->scopeLevel = manager->getCurrentScope()->getScopeLevel();

manager->insertLocal(arr);
```

### 示例 3：函数定义
```cpp
// 解析: int add(int a, int b) { ... }
FunctionEntry* func = new FunctionEntry();
func->name = "add";
func->symbolType = SymbolType::FUNCTION;
func->returnType = DataType::INT;
func->scopeLevel = 0; // 全局作用域

// 添加参数
ParameterEntry* param1 = new ParameterEntry();
param1->name = "a";
param1->dataType = DataType::INT;
param1->paramIndex = 0;
func->addParameter(param1);

ParameterEntry* param2 = new ParameterEntry();
param2->name = "b";
param2->dataType = DataType::INT;
param2->paramIndex = 1;
func->addParameter(param2);

manager->insertFunction(func);
manager->enterFunction(func);
// ... 解析函数体 ...
manager->exitFunction();
```

### 示例 4：符号查找
```cpp
// 查找变量（遵循作用域规则）
VariableEntry* var = manager->lookupVariable("a");
if (var != nullptr) {
    // 使用变量信息
    if (var->isArrayType()) {
        // 处理数组
    }
}

// 查找函数（仅在全局作用域）
FunctionEntry* func = manager->lookupFunction("add");
if (func != nullptr) {
    // 使用函数信息
}
```

---

## 设计说明

### 1. 作用域规则
- **全局作用域**：所有全局变量、常量和函数定义
- **函数作用域**：函数参数和函数体内的局部变量、常量
- **块作用域**：代码块（`{}`）内的局部变量、常量
- **嵌套作用域**：内层作用域可以访问外层作用域的符号，但外层不能访问内层

### 2. 符号查找策略
- 优先在当前作用域查找
- 如果未找到，逐级向上查找父作用域
- 函数定义仅在全局作用域查找

### 3. 类型系统
- 目前 SysY 仅支持 `int` 类型，但设计时应考虑未来扩展
- 数组类型通过 `isArray` 标志和 `dimensions` 列表表示
- 函数参数中的数组类型需要特殊处理（第一维可以为空）

### 4. 内存管理
- 建议使用智能指针管理符号表条目
- 符号表销毁时自动清理所有符号条目
- 注意避免循环引用（如 `FunctionEntry` 持有 `SymbolTable`，`SymbolTable` 持有 `FunctionEntry`）

### 5. 错误处理
- 重复定义：插入符号时检查是否已存在同名符号
- 未定义引用：查找符号时检查是否找到
- 作用域错误：检查符号访问是否合法

### 6. LLVM IR 集成
- 符号条目中存储对应的 LLVM IR 值/函数，便于代码生成阶段使用
- 变量对应 `llvm::Value*`，函数对应 `llvm::Function*`

### 7. 常量表达式处理
- 常量声明中的维度表达式必须是编译时常量
- 需要在语义分析阶段对 `ConstExpNode` 进行求值
- 求值结果存储在 `dimensions` 中

---

## 扩展性考虑

1. **多类型支持**：未来可能支持 `float`、`char` 等类型，`DataType` 枚举可以扩展
2. **结构体支持**：可以添加 `StructEntry` 类型支持结构体定义
3. **作用域信息**：可以添加行号、列号等位置信息用于错误报告
4. **符号表可视化**：可以添加 JSON 导出功能用于调试和可视化

